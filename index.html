<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FLOW-FOIL Luminous Freestanding Display Kit Configurator</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; user-select: none; }
    :root { --primary: #000; --secondary: #fff; --accent: #06d6a2; --gray-light: #f5f5f5; --gray: #e0e0e0; --gray-dark: #888; }
    body { background: var(--secondary); overflow: hidden; }
    .container { display: flex; height: 100vh; }
    .canvas-container { position: relative; width: 45%; height: 100%; background: linear-gradient(to bottom, #000 0%, #1a1a1a 100%); }
    #canvas { width: 100%; height: 100%; display: block; }
    .loading-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.75); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); z-index: 10; }
    .spinner { border: 5px solid rgba(255,255,255,0.3); border-top: 5px solid var(--accent); border-radius: 50%; width:50px; height:50px; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .configurator { width:55%; padding:40px; overflow-y:auto; background: var(--secondary); }
    h1 { font-size:28px; margin-bottom:8px; }
    .subtitle { font-size:13px; color: var(--gray-dark); margin-bottom:24px; }
    p,h2 { font-size:15px; color: var(--gray-dark); margin-bottom:24px; }
    h2 { font-size:20px; margin-top:32px; }
    .required { color: var(--accent); }
    .material-options, .hotspot-panel { display:flex; gap:16px; flex-wrap:wrap; margin-bottom:32px; }
    .material-option, .hotspot-panel button { border:1px solid var(--gray); border-radius:6px; padding:12px 18px; background: var(--secondary); cursor:pointer; transition:all .3s; }
    .material-option.active, .hotspot-panel button.active { border-color: var(--accent); background: rgba(0,255,0,0.05); }
    .material-option:hover, .hotspot-panel button:hover { transform: translateY(-2px); border-color: var(--primary); }
    .material-option.disabled, .hotspot-panel button:disabled { opacity: 0.5; cursor: not-allowed; background: var(--gray-light); }
    .power-control { margin-bottom:32px; }
    #power-toggle { border:1px solid var(--gray); border-radius:6px; padding:12px 18px; background: var(--secondary); cursor:pointer; transition:all .3s; }
    #power-toggle.active { border-color: var(--accent); background: rgba(0,255,0,0.05); }
    #power-toggle:hover { transform: translateY(-2px); border-color: var(--primary); }
    .footer { font-size:12px; color: var(--gray-dark); text-align:center; margin-top:40px; }
    .mobile-sheet-buttons { display: none; }
    
    .pole-status {
      background: var(--gray-light);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 24px;
    }
    
    .pole-side {
      margin-bottom: 12px;
    }
    
    .pole-side h3 {
      font-size: 14px;
      margin-bottom: 8px;
      color: var(--primary);
    }
    
    .pole-fill-bar {
      width: 100%;
      height: 20px;
      background: #ddd;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }
    
    .pole-fill-progress {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #04b085);
      transition: width 0.3s ease;
    }
    
    .pole-fill-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      font-weight: 600;
      color: var(--primary);
    }
    
    .sheet-queue {
      background: rgba(6, 214, 162, 0.1);
      border: 1px solid var(--accent);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 16px;
    }
    
    .queue-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid rgba(6, 214, 162, 0.2);
    }
    
    .queue-item:last-child {
      border-bottom: none;
    }
    
    .queue-item button {
      background: #ff4757;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 10px;
      cursor: pointer;
    }
    
    /* Add notification styles */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(6, 214, 162, 0.9);
      color: white;
      padding: 12px 20px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 1000;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }
    
    .notification.show {
      transform: translateX(0);
    }
    
    .warning-message {
      background-color: rgba(255, 193, 7, 0.1);
      border: 1px solid #ffc107;
      color: #856404;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 16px;
      font-size: 13px;
      display: none;
    }
    
    @media (max-width:768px) {
      body { overflow-y:auto; }
      .container { flex-direction:column; height:auto; }
      .canvas-container { width:100%; height:80vh; }
      .configurator { width:100%; height:80vh; }
      .hotspot-panel, .sheet-format-heading, .instructions { display:none; }
      .mobile-sheet-buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
      .mobile-sheet-buttons button { border-radius: 6px; padding: 8px 12px; background: black; backdrop-filter: blur(5px); margin-top: 25px; transform-origin: center; cursor: pointer; color: white; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="canvas-container">
      <div class="loading-overlay"><div class="spinner"></div></div>
      <canvas id="canvas"></canvas>
    </div>
    <div class="configurator">
      <h1>FLOW-FOIL Luminous Freestanding Display Kit</h1>
      <h2>Choose base material<span class="required">*</span></h2>
      <div class="material-options">
        <div class="material-option active" data-material="metal">Metal</div>
        <div class="material-option" data-material="glass">Glass</div>
      </div>
      <div class="power-control">
        <button id="power-toggle">Power On</button>
      </div>
      
      <!-- Pole Status Display -->
      <div class="pole-status">
        <div class="pole-side">
          <h3>Left Side (150cm pole) - Available: <span id="left-remaining">150cm</span></h3>
          <div class="pole-fill-bar">
            <div id="left-fill-progress" class="pole-fill-progress" style="width: 0%"></div>
            <div id="left-fill-text" class="pole-fill-text">0cm / 150cm</div>
          </div>
        </div>
        <div class="pole-side">
          <h3>Right Side (150cm pole) - Available: <span id="right-remaining">150cm</span></h3>
          <div class="pole-fill-bar">
            <div id="right-fill-progress" class="pole-fill-progress" style="width: 0%"></div>
            <div id="right-fill-text" class="pole-fill-text">0cm / 150cm</div>
          </div>
        </div>
      </div>
      
      <h2 class="sheet-format-heading">Select sheet format<span class="required">*</span></h2>
      <div class="warning-message" id="space-warning" style="display: none;">
        Insufficient space remaining on pole for this sheet format.
      </div>
      
      <!-- Sheet queue for each side -->
      <div id="left-queue" class="sheet-queue" style="display: none;">
        <h3>Left Side Queue:</h3>
        <div id="left-queue-items"></div>
      </div>
      
      <div id="right-queue" class="sheet-queue" style="display: none;">
        <h3>Right Side Queue:</h3>
        <div id="right-queue-items"></div>
      </div>
      
      <div id="hotspot-panel" class="hotspot-panel">
        <button data-format="a4vertical" data-height="30">A4 Vertical (30cm)</button>
        <button data-format="a4landscape" data-height="21">A4 Landscape (21cm)</button>
        <button data-format="a5vertical" data-height="21">A5 Vertical (21cm)</button>
        <button data-format="a5landscape" data-height="15">A5 Landscape (15cm)</button>
        <button data-format="a3vertical" data-height="42">A3 Vertical (42cm)</button>
        <button data-format="a3landscape" data-height="30">A3 Landscape (30cm)</button>
      </div>
      <div id="mobile-sheet-buttons" class="mobile-sheet-buttons">
        <button data-format="a4vertical" data-height="30">A4 Vert.</button>
        <button data-format="a4landscape" data-height="21">A4 Lndscp</button>
        <button data-format="a5vertical" data-height="21">A5 Vert.</button>
        <button data-format="a5landscape" data-height="15">A5 Lndscp</button>
        <button data-format="a3vertical" data-height="42">A3 Vert.</button>
        <button data-format="a3landscape" data-height="30">A3 Lndscp</button>
      </div>
      <h2>Price: <span id="price">117€</span></h2>
      <p class="subtitle">Modular luminous floor display ideal for travel agencies, trade fairs, events, real estate agencies, shops, conference rooms.</p>
      <p class="instructions">Click "Add to Left" or "Add to Right" to place sheets. System automatically calculates optimal positioning based on sheet dimensions and available pole space (150cm display height, 0.5cm spacing, 0.81cm for A5 landscape).</p>
      
      <!-- Side selection buttons -->
      <div class="side-selection" style="margin-bottom: 20px;">
        <button id="add-left" class="material-option">Add to Left Side</button>
        <button id="add-right" class="material-option">Add to Right Side</button>
      </div>
      
      <div class="footer">© 2024 FLOW-FOIL Display Solutions. All rights reserved.</div>
    </div>
  </div>
  
  <!-- Notification for auto-removal -->
  <div id="notification" class="notification">
    Sheet added successfully
  </div>
  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.152.2/build/three.module.js","three/addons/":"https://unpkg.com/three@0.152.2/examples/jsm/","gsap":"https://cdn.jsdelivr.net/npm/gsap@3.11.5/index.js"}}</script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { gsap } from 'gsap';

    // Dynamic pole system configuration
    const POLE_HEIGHT = 130; // cm - ACTUAL pole height (safety margin)
    const DISPLAY_HEIGHT = 150; // cm - What we show in UI
    const MIN_SPACING = 0.5; // cm - base spacing
    const A5_LANDSCAPE_SPACING = 0.81; // cm - 1.62x spacing for A5 landscape
    const POLE_BASE_Y = -1.8; // 3D scene Y coordinate for pole base (adjusted to match actual pole)
    const POLE_TOP_Y = 0.6; // 3D scene Y coordinate for pole top (more conservative limit)
    const CM_TO_SCENE_RATIO = (POLE_TOP_Y - POLE_BASE_Y) / POLE_HEIGHT; // conversion factor

    // Get spacing for specific format
    function getSpacingForFormat(format) {
      return format === 'a5landscape' ? A5_LANDSCAPE_SPACING : MIN_SPACING;
    }

    // Sheet dimensions in cm (height when placed)
    const SHEET_DIMENSIONS = {
      a4vertical: { height: 30, displayName: 'A4 Vertical (30cm)' },
      a4landscape: { height: 21, displayName: 'A4 Landscape (21cm)' },
      a5vertical: { height: 21, displayName: 'A5 Vertical (21cm)' },
      a5landscape: { height: 15, displayName: 'A5 Landscape (15cm)' },
      a3vertical: { height: 42, displayName: 'A3 Vertical (42cm)' },
      a3landscape: { height: 30, displayName: 'A3 Landscape (30cm)' }
    };

    // Dynamic pole state management
    const poleState = {
      left: { sheets: [], totalHeight: 0, remainingHeight: POLE_HEIGHT },
      right: { sheets: [], totalHeight: 0, remainingHeight: POLE_HEIGHT }
    };

    let selectedFormat = null;
    let pendingSide = null;

    const isMobile = window.innerWidth <= 768;
    const canvas = document.getElementById('canvas');
    const loading = document.querySelector('.loading-overlay');
    const startZ = isMobile ? -2 : -2.73;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(isMobile ? 1.5 : window.devicePixelRatio);
    renderer.toneMapping = isMobile ? THREE.LinearToneMapping : THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.48;
    renderer.domElement.style.touchAction = 'none';

    const camera = new THREE.PerspectiveCamera(65, 1, 0.1, 1000);
    camera.position.set(-1.3, 0.75, startZ);
    const target = new THREE.Vector3(0, 0, 0);
    camera.lookAt(target);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, -1, 0);
    controls.enableDamping = !isMobile;
    controls.dampingFactor = 0.05;
    controls.minDistance = 1;
    controls.maxDistance = 20;
    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI - 0.1;

    function resize() {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const cw = isMobile ? vw : vw * 0.45;
      const ch = isMobile ? vh * 0.8 : vh;
      renderer.setSize(cw, ch);
      camera.aspect = cw / ch;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    const scene = new THREE.Scene();
    const ambient = new THREE.AmbientLight(0xffffff, 0.726);
    scene.add(ambient);
    const dl = new THREE.DirectionalLight(0xffffff, 0.7318);
    dl.position.set(2, 3, 7);
    if (isMobile) dl.castShadow = false;
    scene.add(dl);
    const fl = new THREE.DirectionalLight(0xffffff, isMobile ? 0.05 : 0.063);
    fl.position.set(-1, 4, -3);
    scene.add(fl);

    let fullModel;
    let glassBaseMesh = null;
    const modelParts = {};
    let powerOn = false;

    // Pricing system
    let basePrice = 100;
    let materialExtra = { metal: 0, glass: 10 };
    let sheetPrices = {
      a4vertical: 15,
      a4landscape: 17,
      a5vertical: 12,
      a5landscape: 14,
      a3vertical: 21,
      a3landscape: 27,
    };

    // Calculate if a sheet can fit on a side - STRICT checking with dynamic spacing
    function canFitSheet(side, format) {
      const sheetHeight = SHEET_DIMENSIONS[format].height;
      const spacingNeeded = poleState[side].sheets.length > 0 ? getSpacingForFormat(format) : 0;
      const totalNeeded = sheetHeight + spacingNeeded;
      
      // Use real pole height for validation
      const hasEnoughSpace = poleState[side].remainingHeight >= totalNeeded;
      
      console.log(`Can fit ${format} on ${side}? Need: ${totalNeeded}cm (${sheetHeight}cm + ${spacingNeeded}cm spacing), Available: ${poleState[side].remainingHeight}cm, Real pole: ${POLE_HEIGHT}cm, Result: ${hasEnoughSpace}`);
      
      return hasEnoughSpace;
    }

    // Calculate Y position for a new sheet (stack from bottom up) - FIXED spacing logic
    function calculateSheetPosition(side, format) {
      const sheets = poleState[side].sheets;
      let cumulativeHeight = 0;
      
      // Calculate cumulative height from existing sheets
      sheets.forEach((sheet) => {
        cumulativeHeight += sheet.height;
        // Add spacing after each existing sheet
        cumulativeHeight += sheet.spacing || MIN_SPACING;
      });
      
      // Convert to 3D scene coordinates (from bottom of pole upward)
      const yPosition = POLE_BASE_Y + (cumulativeHeight * CM_TO_SCENE_RATIO);
      
      // Safety check - never exceed pole bounds
      const maxAllowedY = POLE_TOP_Y - (SHEET_DIMENSIONS[format].height * CM_TO_SCENE_RATIO);
      const finalY = Math.min(yPosition, maxAllowedY);
      
      console.log(`Positioning ${format} on ${side}: Cumulative: ${cumulativeHeight}cm, Y: ${yPosition}, Final Y: ${finalY}, Next spacing: ${getSpacingForFormat(format)}cm`);
      
      return finalY;
    }

    // Add sheet to pole side - IMPROVED with strict validation
    function addSheetToPole(side, format) {
      // Double-check space before proceeding
      if (!canFitSheet(side, format)) {
        const spacingNeeded = poleState[side].sheets.length > 0 ? getSpacingForFormat(format) : 0;
        const needed = SHEET_DIMENSIONS[format].height + spacingNeeded;
        showNotification(`Cannot fit ${SHEET_DIMENSIONS[format].displayName} on ${side} side. Need ${needed}cm, only ${Math.round(poleState[side].remainingHeight)}cm available.`, 4000);
        return false;
      }

      const sheetHeight = SHEET_DIMENSIONS[format].height;
      const yPosition = calculateSheetPosition(side, format);
      
      // Final safety check - never allow positioning above pole
      if (yPosition + (sheetHeight * CM_TO_SCENE_RATIO) > POLE_TOP_Y) {
        showNotification(`Sheet would exceed pole height on ${side} side`, 3000);
        return false;
      }
      
      // Load and place 3D model
      const file = (side === 'right' ? mapR[format] : mapL[format]) + '.glb';
      
      gltfLoader.load('/3dmodels/' + file, g => {
        const s = g.scene;
        const bb = new THREE.Box3().setFromObject(s);
        s.position.y -= bb.min.y;
        const grp = new THREE.Group();
        grp.add(s);
        
        // Position the sheet (bottom-up stacking) - ADJUSTED X POSITIONING
        const x = side === 'left' ? -0.01 : 0.011; // Moved closer to center
        grp.position.set(x, yPosition, 0.003);
        grp.quaternion.copy(fullModel.quaternion);
        grp.scale.copy(fullModel.scale);
        
        scene.add(grp);
        
        // Update pole state with spacing information
        const sheetData = {
          format: format,
          height: sheetHeight,
          yPosition: yPosition,
          group: grp,
          spacing: getSpacingForFormat(format), // Store spacing for this format
          id: Date.now() + Math.random()
        };
        
        poleState[side].sheets.push(sheetData);
        
        // Recalculate totals properly
        updateSideTotals(side);
        
        updateUI();
        updatePrice();
        updateEmission();
        
        showNotification(`${SHEET_DIMENSIONS[format].displayName} added to ${side} side`);
      });
      
      return true;
    }

    // Remove sheet from pole
    function removeSheetFromPole(side, sheetId) {
      const sideData = poleState[side];
      const sheetIndex = sideData.sheets.findIndex(s => s.id === sheetId);
      
      if (sheetIndex === -1) return false;
      
      const sheet = sideData.sheets[sheetIndex];
      
      // Remove from scene
      scene.remove(sheet.group);
      
      // Remove from state
      sideData.sheets.splice(sheetIndex, 1);
      
      // Recalculate positions for remaining sheets
      repositionAllSheets(side);
      
      // Update totals
      updateSideTotals(side);
      updateUI();
      updatePrice();
      updateEmission();
      
      showNotification(`Sheet removed from ${side} side`);
      return true;
    }

    // Reposition all sheets on a side (after removal) - FIXED spacing logic
    function repositionAllSheets(side) {
      const sheets = poleState[side].sheets;
      let cumulativeHeight = 0;
      
      sheets.forEach((sheet, index) => {
        // Position this sheet at current cumulative height
        const yPosition = POLE_BASE_Y + (cumulativeHeight * CM_TO_SCENE_RATIO);
        
        // Safety check
        const maxY = POLE_TOP_Y - (sheet.height * CM_TO_SCENE_RATIO);
        const finalY = Math.min(yPosition, maxY);
        
        sheet.yPosition = finalY;
        sheet.group.position.y = finalY;
        
        // Add this sheet's height to cumulative
        cumulativeHeight += sheet.height;
        
        // Add spacing after this sheet (except for the last one)
        if (index < sheets.length - 1) {
          cumulativeHeight += sheet.spacing || MIN_SPACING;
        }
      });
    }

    // Update side totals after changes - FIXED spacing logic
    function updateSideTotals(side) {
      const sideData = poleState[side];
      sideData.totalHeight = 0;
      
      sideData.sheets.forEach((sheet, index) => {
        sideData.totalHeight += sheet.height;
        // Add spacing after each sheet except the last
        if (index < sideData.sheets.length - 1) {
          sideData.totalHeight += sheet.spacing || MIN_SPACING;
        }
      });
      
      sideData.remainingHeight = Math.max(0, POLE_HEIGHT - sideData.totalHeight);
      
      console.log(`${side} side totals: Used: ${sideData.totalHeight}cm, Remaining: ${sideData.remainingHeight}cm (Real pole: ${POLE_HEIGHT}cm)`);
    }

    // Update UI elements (show display height, calculate with real height)
    function updateUI() {
      // Update pole fill bars
      ['left', 'right'].forEach(side => {
        // Use real height for calculations but display height for UI
        const realFillPercent = (poleState[side].totalHeight / POLE_HEIGHT) * 100;
        const displayFillPercent = (poleState[side].totalHeight / DISPLAY_HEIGHT) * 100;
        
        const progressBar = document.getElementById(`${side}-fill-progress`);
        const fillText = document.getElementById(`${side}-fill-text`);
        const remainingText = document.getElementById(`${side}-remaining`);
        
        progressBar.style.width = displayFillPercent + '%'; // Show based on 150cm
        fillText.textContent = `${Math.round(poleState[side].totalHeight)}cm / 150cm`; // Show 150cm
        if (remainingText) {
          // Show remaining based on display height for UI
          const displayRemaining = DISPLAY_HEIGHT - poleState[side].totalHeight;
          remainingText.textContent = `${Math.round(Math.max(0, displayRemaining))}cm`;
        }
        
        // Update queue display
        updateQueueDisplay(side);
      });
      
      // Update button states based on available space (use real height)
      updateButtonStates();
    }

    // Update queue display for each side
    function updateQueueDisplay(side) {
      const queueElement = document.getElementById(`${side}-queue`);
      const queueItems = document.getElementById(`${side}-queue-items`);
      
      if (poleState[side].sheets.length === 0) {
        queueElement.style.display = 'none';
        return;
      }
      
      queueElement.style.display = 'block';
      queueItems.innerHTML = '';
      
      poleState[side].sheets.forEach((sheet, index) => {
        const queueItem = document.createElement('div');
        queueItem.className = 'queue-item';
        
        const span = document.createElement('span');
        span.textContent = SHEET_DIMENSIONS[sheet.format].displayName;
        
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', () => removeSheetFromPole(side, sheet.id));
        
        queueItem.appendChild(span);
        queueItem.appendChild(removeBtn);
        queueItems.appendChild(queueItem);
      });
    }

    // Update button states based on available space
    function updateButtonStates() {
      const buttons = document.querySelectorAll('[data-format]');
      
      buttons.forEach(button => {
        const format = button.dataset.format;
        const leftCanFit = canFitSheet('left', format);
        const rightCanFit = canFitSheet('right', format);
        
        // Update button appearance based on space availability
        if (!leftCanFit && !rightCanFit) {
          button.disabled = true;
          button.style.opacity = '0.3';
        } else {
          button.disabled = false;
          button.style.opacity = '1';
        }
        
        // Show warning if no space
        const warning = document.getElementById('space-warning');
        const anyCanFit = Array.from(buttons).some(btn => {
          const fmt = btn.dataset.format;
          return canFitSheet('left', fmt) || canFitSheet('right', fmt);
        });
        warning.style.display = anyCanFit ? 'none' : 'block';
      });
    }

    // Update price calculation
    function updatePrice() {
      let p = basePrice;
      const matElement = document.querySelector('.material-option.active');
      if (matElement) {
        const mat = matElement.dataset.material;
        p += materialExtra[mat];
        
        let sheetTotal = 0;
        ['left', 'right'].forEach(side => {
          poleState[side].sheets.forEach(sheet => {
            sheetTotal += sheetPrices[sheet.format] || 0;
          });
        });
        
        p += sheetTotal;
        document.getElementById('price').textContent = p + '€';
      }
    }

    // Update emission for power state
    function updateEmission() {
      ['left', 'right'].forEach(side => {
        poleState[side].sheets.forEach(sheet => {
          sheet.group.traverse(o => {
            if (o.isMesh) {
              if (powerOn) {
                o.material.emissive = new THREE.Color(0xffffff);
                o.material.emissiveIntensity = 0.75;
                o.material.emissiveMap = o.material.map;
              } else {
                o.material.emissiveIntensity = 0;
              }
              o.material.needsUpdate = true;
            }
          });
        });
      });
    }

    // Show notification
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.classList.add('show');
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, duration);
    }

    // Power toggle
    document.getElementById('power-toggle').addEventListener('click', () => {
      powerOn = !powerOn;
      const btn = document.getElementById('power-toggle');
      btn.textContent = powerOn ? 'Power Off' : 'Power On';
      btn.classList.toggle('active', powerOn);
      updateEmission();
    });

    // Material selection
    document.querySelectorAll('.material-option').forEach(el => el.addEventListener('click', () => {
      if (el.textContent.includes('Add to')) return; // Skip side selection buttons
      
      document.querySelectorAll('.material-option').forEach(b => {
        if (!b.textContent.includes('Add to')) {
          b.classList.toggle('active', b === el);
        }
      });
      
      const m = el.dataset.material;
      
      if (m === 'metal') {
        if (glassBaseMesh) { scene.remove(glassBaseMesh); glassBaseMesh = null; }
        modelParts.metalbase.visible = true;
        if (modelParts.glassbase) modelParts.glassbase.visible = false;
      } else {
        modelParts.metalbase.visible = false;
        if (glassBaseMesh) scene.remove(glassBaseMesh);
        gltfLoader.load('3dmodels/glassbase.glb', g => {
          glassBaseMesh = g.scene;
          ['position','quaternion','scale'].forEach(k => glassBaseMesh[k].copy(fullModel[k]));
          scene.add(glassBaseMesh);
        });
      }
      updatePrice();
    }));

    // Side selection
    document.getElementById('add-left').addEventListener('click', () => {
      if (selectedFormat) {
        addSheetToPole('left', selectedFormat);
        selectedFormat = null;
        document.querySelectorAll('[data-format]').forEach(b => b.classList.remove('active'));
      } else {
        showNotification("Please select a sheet format first");
      }
    });

    document.getElementById('add-right').addEventListener('click', () => {
      if (selectedFormat) {
        addSheetToPole('right', selectedFormat);
        selectedFormat = null;
        document.querySelectorAll('[data-format]').forEach(b => b.classList.remove('active'));
      } else {
        showNotification("Please select a sheet format first");
      }
    });

    const draco = new DRACOLoader().setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.5/');
    const gltfLoader = new GLTFLoader().setDRACOLoader(draco);
    const rgbeLoader = new RGBELoader();

    rgbeLoader.load('3dmodels/docklands_02_1k.hdr', hdr => {
      hdr.mapping = THREE.EquirectangularReflectionMapping;
      scene.environment = hdr;
      loadHolder();
    });

    function loadHolder() {
      gltfLoader.load('/3dmodels/adsholder.glb', gltf => {
        fullModel = gltf.scene;
        fullModel.position.set(0, -2, 0);
        fullModel.traverse(o => {
          if (o.name) modelParts[o.name] = o;
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material.map) o.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
          }
        });
        modelParts.metalbase.visible = true;
        if (modelParts.glassbase) modelParts.glassbase.visible = false;
        scene.add(fullModel);

        loading.style.display = 'none';
        updateUI();
        updatePrice();
      });
    }

    const mapR = { a4vertical: 'a4vertlf8', a4landscape: 'a4landslf8', a5vertical: 'a3vertlf8', a5landscape: 'a3landslf8', a3vertical: 'a5vertlf8', a3landscape: 'a5landslf8' };
    const mapL = { a4vertical: 'a4vertr8', a4landscape: 'a4landsr8', a5vertical: 'a3vertr8', a5landscape: 'a3landsr8', a3vertical: 'a5vertr8', a3landscape: 'a5landsr8' };

    // Sheet format selection
    function bindBtns(btns) {
      btns.forEach(b => b.addEventListener('click', () => {
        // Toggle selection
        const wasActive = b.classList.contains('active');
        document.querySelectorAll('[data-format]').forEach(btn => btn.classList.remove('active'));
        
        if (!wasActive) {
          b.classList.add('active');
          selectedFormat = b.dataset.format;
          showNotification(`${SHEET_DIMENSIONS[selectedFormat].displayName} selected. Choose a side to add it.`);
        } else {
          selectedFormat = null;
        }
      }));
    }

    bindBtns(document.querySelectorAll('#hotspot-panel button'));
    bindBtns(document.querySelectorAll('#mobile-sheet-buttons button'));

    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();

    // Initialize UI
    setTimeout(() => {
      updateUI();
    }, 100);
  </script>
</body>
</html>