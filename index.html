<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FLOW-FOIL Luminous Freestanding Display Kit Configurator</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; user-select: none; }
    :root { --primary: #000; --secondary: #fff; --accent: #06d6a2; --gray-light: #f5f5f5; --gray: #e0e0e0; --gray-dark: #888; }
    body { background: var(--secondary); overflow: hidden; }
    .container { display: flex; height: 100vh; }
    .canvas-container { position: relative; width: 45%; height: 100%; background: linear-gradient(to bottom, #000 0%, #1a1a1a 100%); }
    #canvas { width: 100%; height: 100%; display: block; }
    .loading-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.75); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); z-index: 10; }
    .spinner { border: 5px solid rgba(255,255,255,0.3); border-top: 5px solid var(--accent); border-radius: 50%; width:50px; height:50px; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .configurator { width:55%; padding:40px; overflow-y:auto; background: var(--secondary); }
    h1 { font-size:28px; margin-bottom:8px; }
    .subtitle { font-size:13px; color: var(--gray-dark); margin-bottom:24px; }
    p,h2 { font-size:15px; color: var(--gray-dark); margin-bottom:24px; }
    h2 { font-size:20px; margin-top:32px; }
    .required { color: var(--accent); }
    .material-options, .hotspot-panel { display:flex; gap:16px; flex-wrap:wrap; margin-bottom:32px; }
    .material-option, .hotspot-panel button { border:1px solid var(--gray); border-radius:6px; padding:12px 18px; background: var(--secondary); cursor:pointer; transition:all .3s; }
    .material-option.active, .hotspot-panel button.active { border-color: var(--accent); background: rgba(0,255,0,0.05); }
    .material-option:hover, .hotspot-panel button:hover { transform: translateY(-2px); border-color: var(--primary); }
    .power-control { margin-bottom:32px; }
    #power-toggle { border:1px solid var(--gray); border-radius:6px; padding:12px 18px; background: var(--secondary); cursor:pointer; transition:all .3s; }
    #power-toggle.active { border-color: var(--accent); background: rgba(0,255,0,0.05); }
    #power-toggle:hover { transform: translateY(-2px); border-color: var(--primary); }
    .footer { font-size:12px; color: var(--gray-dark); text-align:center; margin-top:40px; }
    .mobile-sheet-buttons { display: none; }
    @media (max-width:768px) {
      body { overflow-y:auto; }
      .container { flex-direction:column; height:auto; }
      .canvas-container { width:100%; height:80vh; }
      .configurator { width:100%; height:80vh; }
      .hotspot-panel, .sheet-format-heading, .instructions { display:none; }
      .mobile-sheet-buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
      .mobile-sheet-buttons button { border-radius: 6px; padding: 8px 12px; background: black; backdrop-filter: blur(5px); margin-top: 25px; transform-origin: center; cursor: pointer; color: white; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="canvas-container">
      <div class="loading-overlay"><div class="spinner"></div></div>
      <canvas id="canvas"></canvas>
    </div>
    <div class="configurator">
      <h1>FLOW-FOIL Luminous Freestanding Display Kit</h1>
      <h2>Choose base material<span class="required">*</span></h2>
      <div class="material-options">
        <div class="material-option active" data-material="metal">Metal</div>
        <div class="material-option" data-material="glass">Glass</div>
      </div>
      <div class="power-control">
        <button id="power-toggle">Power On</button>
      </div>
      <h2 class="sheet-format-heading">Select sheet format<span class="required">*</span></h2>
      <div id="hotspot-panel" class="hotspot-panel">
        <button data-format="a4vertical">A4 Vertical</button>
        <button data-format="a4landscape">A4 Landscape</button>
        <button data-format="a5vertical">A5 Vertical</button>
        <button data-format="a5landscape">A5 Landscape</button>
        <button data-format="a3vertical">A3 Vertical</button>
        <button data-format="a3landscape">A3 Landscape</button>
      </div>
      <div id="mobile-sheet-buttons" class="mobile-sheet-buttons">
        <button data-format="a4vertical">A4 Vert.</button>
        <button data-format="a4landscape">A4 Lndscp</button>
        <button data-format="a5vertical">A5 Vert.</button>
        <button data-format="a5landscape">A5 Lndscp</button>
        <button data-format="a3vertical">A3 Vert.</button>
        <button data-format="a3landscape">A3 Lndscp</button>
      </div>
      <h2>Price: <span id="price">117€</span></h2>
      <p class="subtitle">Modular luminous floor display ideal for travel agencies, trade fairs, events, real estate agencies, shops, conference rooms.</p>
      <p class="instructions">Click a hotspot to load your sheet. Toggle base material, then choose sheet.</p>
      <div class="footer">© 2024 FLOW-FOIL Display Solutions. All rights reserved.</div>
    </div>
  </div>
  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.152.2/build/three.module.js","three/addons/":"https://unpkg.com/three@0.152.2/examples/jsm/","gsap":"https://cdn.jsdelivr.net/npm/gsap@3.11.5/index.js"}}</script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { gsap } from 'gsap';

    const isMobile = window.innerWidth <= 768;
    const canvas = document.getElementById('canvas');
    const loading = document.querySelector('.loading-overlay');

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(isMobile ? 1 : window.devicePixelRatio);
    renderer.toneMapping = isMobile ? THREE.LinearToneMapping : THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.48;
    renderer.domElement.style.touchAction = 'none';

    const camera = new THREE.PerspectiveCamera(65, 1, 0.1, 1000);
    camera.position.set(0, 1.5, -2.73);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, -1, 0);
    controls.enableDamping = !isMobile;
    controls.dampingFactor = 0.05;
    controls.minDistance = 1;
    controls.maxDistance = 20;
    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI - 0.1;

    function resize() {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const cw = isMobile ? vw : vw * 0.45;
      const ch = isMobile ? vh * 0.8 : vh;
      renderer.setSize(cw, ch);
      camera.aspect = cw / ch;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    const scene = new THREE.Scene();
    const ambient = new THREE.AmbientLight(0xffffff, 0.726);
    scene.add(ambient);
    const dl = new THREE.DirectionalLight(0xffffff, 0.7318);
    dl.position.set(2, 3, 7);
    if (isMobile) dl.castShadow = false;
    scene.add(dl);
    const fl = new THREE.DirectionalLight(0xffffff, isMobile ? 0.05 : 0.063);
    fl.position.set(-1, 4, -3);
    scene.add(fl);

    let fullModel;
    let glassBaseMesh = null;
    const modelParts = {};
    const sheets = {};
    const sheetFormats = {};
    const loadingSheets = {};
    const sprites = [];
    let active = null;
    let powerOn = false;

    const basePrice = 100;
    const materialExtra = { metal: 0, glass: 10 };
    const sheetPrices = {
      a4vertical: 15,
      a4landscape: 17,
      a5vertical: 12,
      a5landscape: 14,
      a3vertical: 21,
      a3landscape: 27,
    };

    function updatePrice() {
      let p = basePrice;
      const mat = document.querySelector('.material-option.active').dataset.material;
      p += materialExtra[mat];
      for (const id in sheetFormats) p += sheetPrices[sheetFormats[id]];
      document.getElementById('price').textContent = p + '€';
    }

    function updateEmission() {
      Object.values(sheets).forEach(grp => {
        grp.traverse(o => {
          if (o.isMesh) {
            if (powerOn) {
              o.material.emissive = new THREE.Color(0xffffff);
              o.material.emissiveIntensity = 0.75;
              o.material.emissiveMap = o.material.map;
            } else {
              o.material.emissiveIntensity = 0;
            }
            o.material.needsUpdate = true;
          }
        });
      });
    }

    document.getElementById('power-toggle').addEventListener('click', () => {
      powerOn = !powerOn;
      const btn = document.getElementById('power-toggle');
      btn.textContent = powerOn ? 'Power Off' : 'Power On';
      btn.classList.toggle('active', powerOn);
      updateEmission();
    });

    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const draco = new DRACOLoader().setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.5/');
    const gltfLoader = new GLTFLoader().setDRACOLoader(draco);
    const rgbeLoader = new RGBELoader();

    function makeHotspotTex(color) {
      const size = 128;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const r = size / 2;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(r, r, r, 0, 2 * Math.PI);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = size * 0.12;
      const L = size * 0.6;
      ctx.beginPath();
      ctx.moveTo(r - L / 2, r);
      ctx.lineTo(r + L / 2, r);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(r, r - L / 2);
      ctx.lineTo(r, r + L / 2);
      ctx.stroke();
      return new THREE.CanvasTexture(c);
    }

    function makeClearHotspotTex(color) {
      const size = 128;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const r = size / 2;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(r, r, r, 0, 2 * Math.PI);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = size * 0.12;
      const L = size * 0.6;
      ctx.beginPath();
      ctx.moveTo(r - L / 2, r - L / 2);
      ctx.lineTo(r + L / 2, r + L / 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(r + L / 2, r - L / 2);
      ctx.lineTo(r - L / 2, r + L / 2);
      ctx.stroke();
      return new THREE.CanvasTexture(c);
    }

    const plusTex = makeHotspotTex('#000');
    const plusHoverTex = makeHotspotTex('var(--accent)');
    const clearTex = makeClearHotspotTex('#000');
    const clearHoverTex = makeClearHotspotTex('#ff0000');

    rgbeLoader.load('docklands_02_1k.hdr', hdr => {
      hdr.mapping = THREE.EquirectangularReflectionMapping;
      scene.environment = hdr;
      loadHolder();
    });

    function loadHolder() {
      gltfLoader.load('/adsholder.glb', gltf => {
        fullModel = gltf.scene;
        fullModel.position.set(0, -2, 0);
        fullModel.traverse(o => {
          if (o.name) modelParts[o.name] = o;
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material.map) o.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
          }
        });
        modelParts.metalbase.visible = true;
        if (modelParts.glassbase) modelParts.glassbase.visible = false;
        scene.add(fullModel);

        gltfLoader.load('/a4landsr8.glb', g => {
          const s = g.scene;
          const bb = new THREE.Box3().setFromObject(s);
          s.position.y -= bb.min.y;
          const grp = new THREE.Group();
          grp.add(s);
          grp.position.set(0.004, 1.8253 - 2, 0.003);
          grp.quaternion.copy(fullModel.quaternion);
          grp.scale.copy(fullModel.scale);
          scene.add(grp);
          sheets[5] = grp;
          sheetFormats[5] = 'a4landscape';
          loading.style.display = 'none';
          updatePrice();
          updateEmission();
        });

        const posList = [
          [0.021, 1.8253, 0.003],
          [0.021, 1.449, 0.003],
          [0.021, 1.071, 0.003],
          [0.021, 0.688, 0.003],
          [0.021, 0.3, 0.003],
          [-0.02, 1.82753, 0.003],
          [-0.02, 1.449, 0.003],
          [-0.02, 1.071, 0.003],
          [-0.02, 0.688, 0.003],
          [-0.02, 0.3, 0.003],
        ];
        posList.forEach((p, i) => {
          const zOff = 0.01 - 0.04;
          const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: plusTex, transparent: true }));
          sp.position.set(p[0], p[1] - 2, p[2] + zOff);
          sp.scale.set(0.075, 0.075, 1);
          sp.userData = { id: i, side: p[0] > 0 ? 'right' : 'left', baseZ: p[2], textures: { plus: plusTex, hover: plusHoverTex, clear: clearTex } };
          scene.add(sp);
          sprites.push(sp);
        });
      });
    }

    document.querySelectorAll('.material-option').forEach(el => el.addEventListener('click', () => {
      document.querySelectorAll('.material-option').forEach(b => b.classList.toggle('active', b === el));
      const m = el.dataset.material;
      if (m === 'metal') {
        if (glassBaseMesh) { scene.remove(glassBaseMesh); glassBaseMesh = null; }
        modelParts.metalbase.visible = true;
        if (modelParts.glassbase) modelParts.glassbase.visible = false;
      } else {
        modelParts.metalbase.visible = false;
        if (glassBaseMesh) scene.remove(glassBaseMesh);
        gltfLoader.load('/glassbase.glb', g => {
          glassBaseMesh = g.scene;
          ['position','quaternion','scale'].forEach(k => glassBaseMesh[k].copy(fullModel[k]));
          scene.add(glassBaseMesh);
        });
      }
      updatePrice();
    }));

    const mapR = { a4vertical: 'a4vertlf8', a4landscape: 'a4landslf8', a5vertical: 'a3vertlf8', a5landscape: 'a3landslf8', a3vertical: 'a5vertlf8', a3landscape: 'a5landslf8' };
    const mapL = { a4vertical: 'a4vertr8', a4landscape: 'a4landsr8', a5vertical: 'a3vertr8', a5landscape: 'a3landsr8', a3vertical: 'a5vertr8', a3landscape: 'a5landsr8' };

    function pick(x, y) {
      ray.setFromCamera(new THREE.Vector2(x, y), camera);
      const h = ray.intersectObjects(sprites)[0];
      return h ? h.object : null;
    }

    renderer.domElement.addEventListener('pointerdown', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      const hit = pick(x, y);
      sprites.forEach(sp => {
        if (sp === hit) {
          if (sp.material.map === sp.userData.textures.plus) sp.material.map = sp.userData.textures.hover;
          else if (sp.material.map === clearTex) sp.material.map = clearHoverTex;
          sp.material.needsUpdate = true;
        } else {
          if (sp.material.map === plusHoverTex) { sp.material.map = plusTex; sp.material.needsUpdate = true; }
          if (sp.material.map === clearHoverTex) { sp.material.map = clearTex; sp.material.needsUpdate = true; }
        }
      });
      if (!hit) return;
      const id = hit.userData.id;
      if (sheets[id]) {
        scene.remove(sheets[id]);
        delete sheets[id];
        delete sheetFormats[id];
        hit.material.map = plusTex;
        hit.material.needsUpdate = true;
        active = null;
      } else if (active === hit) {
        hit.material.map = plusTex;
        hit.material.needsUpdate = true;
        active = null;
      } else {
        hit.material.map = clearTex;
        hit.material.needsUpdate = true;
        active = hit;
      }
      updatePrice();
      updateEmission();
    }, { passive: false });

    function bindBtns(btns) {
      btns.forEach(b => b.addEventListener('click', () => {
        if (!active) return;
        const id = active.userData.id;
        if (loadingSheets[id]) return;
        loadingSheets[id] = true;
        const fmt = b.dataset.format;
        const side = active.userData.side;
        const file = (side === 'right' ? mapR[fmt] : mapL[fmt]) + '.glb';
        if (sheets[id]) {
          scene.remove(sheets[id]);
          delete sheets[id];
          delete sheetFormats[id];
        }
        gltfLoader.load('/' + file, g => {
          const s = g.scene;
          const bb = new THREE.Box3().setFromObject(s);
          s.position.y -= bb.min.y;
          const grp = new THREE.Group();
          grp.add(s);
          const p = active.position.clone();
          p.z = active.userData.baseZ;
          p.x += side === 'left' ? 0.025 : -0.025;
          grp.position.copy(p);
          grp.quaternion.copy(fullModel.quaternion);
          grp.scale.copy(fullModel.scale);
          scene.add(grp);
          sheets[id] = grp;
          sheetFormats[id] = fmt;
          loadingSheets[id] = false;
          updatePrice();
          updateEmission();
        });
      }));
    }

    bindBtns(document.querySelectorAll('#hotspot-panel button'));
    bindBtns(document.querySelectorAll('#mobile-sheet-buttons button'));

    renderer.domElement.addEventListener('pointermove', e => {
      const rect = canvas.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      const hoverHit = pick(x, y);
      sprites.forEach(sp => {
        if (sp === hoverHit) {
          if (sp.material.map === plusTex) sp.material.map = plusHoverTex;
          else if (sp.material.map === clearTex) sp.material.map = clearHoverTex;
          sp.material.needsUpdate = true;
        } else {
          if (sp.material.map === plusHoverTex) { sp.material.map = plusTex; sp.material.needsUpdate = true; }
          if (sp.material.map === clearHoverTex) { sp.material.map = clearTex; sp.material.needsUpdate = true; }
        }
      });
    });

    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
