<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FLOW-FOIL Luminous Freestanding Display Kit Configurator</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; user-select: none; }
    :root { --primary: #000; --secondary: #fff; --accent: #06d6a2; --gray-light: #f5f5f5; --gray: #e0e0e0; --gray-dark: #888; }
    body { background: var(--secondary); overflow: hidden; }
    .container { display: flex; height: 100vh; }
    .canvas-container { position: relative; width: 45%; height: 100%; background: linear-gradient(to bottom, #000 0%, #1a1a1a 100%); }
    #canvas { width: 100%; height: 100%; display: block; }
    .loading-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.75); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); z-index: 10; }
    .spinner { border: 5px solid rgba(255,255,255,0.3); border-top: 5px solid var(--accent); border-radius: 50%; width:50px; height:50px; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .configurator { width:55%; padding:40px; overflow-y:auto; background: var(--secondary); }
    h1 { font-size:28px; margin-bottom:8px; }
    .subtitle { font-size:13px; color: var(--gray-dark); margin-bottom:24px; }
    p,h2 { font-size:15px; color: var(--gray-dark); margin-bottom:24px; }
    h2 { font-size:20px; margin-top:32px; }
    .required { color: var(--accent); }
    .material-options, .hotspot-panel { display:flex; gap:16px; flex-wrap:wrap; margin-bottom:32px; }
    .material-option, .hotspot-panel button { border:1px solid var(--gray); border-radius:6px; padding:12px 18px; background: var(--secondary); cursor:pointer; transition:all .3s; }
    .material-option.active, .hotspot-panel button.active { border-color: var(--accent); background: rgba(0,255,0,0.05); }
    .material-option:hover, .hotspot-panel button:hover { transform: translateY(-2px); border-color: var(--primary); }
    .footer { font-size:12px; color: var(--gray-dark); text-align:center; margin-top:40px; }
    .mobile-sheet-buttons { display:none; }
    @media (max-width:768px) {
      body { overflow-y:auto; }
      .container { flex-direction:column; height:auto; }
      .canvas-container { width:100%; height:80vh; }
      .configurator { width:100%; height:50vh; }
      .hotspot-panel, .sheet-format-heading, .instructions { display:none; }
      .mobile-sheet-buttons { display:flex; position:absolute; bottom:16px; left:50%; transform:translateX(-50%); gap:12px; z-index:5; }
      .mobile-sheet-buttons button { border:1px solid var(--gray); border-radius:6px; padding:8px 12px; background:var(--secondary); backdrop-filter: blur(5px); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="canvas-container">
      <div class="loading-overlay"><div class="spinner"></div></div>
      <canvas id="canvas"></canvas>
      <div id="mobile-sheet-buttons" class="mobile-sheet-buttons">
        <button data-format="a4vertical">A4 Vertical</button>
        <button data-format="a4landscape">A4 Landscape</button>
        <button data-format="a5vertical">A5 Vertical</button>
        <button data-format="a5landscape">A5 Landscape</button>
      </div>
    </div>
    <div class="configurator">
      <h1>FLOW-FOIL Luminous Freestanding Display Kit</h1>
      <p class="subtitle">Modular luminous floor display ideal for travel agencies, trade fairs, events, real estate agencies, shops, conference rooms.</p>
      <p class="instructions">Click a hotspot to load your sheet. Toggle base material, then choose sheet.</p>
      <h2>Choose base material<span class="required">*</span></h2>
      <div class="material-options">
        <div class="material-option active" data-material="metal">Metal</div>
        <div class="material-option" data-material="glass">Glass</div>
      </div>
      <h2 class="sheet-format-heading">Select sheet format<span class="required">*</span></h2>
      <div id="hotspot-panel" class="hotspot-panel">
        <button data-format="a4vertical">A4 Vertical</button>
        <button data-format="a4landscape">A4 Landscape</button>
        <button data-format="a5vertical">A5 Vertical</button>
        <button data-format="a5landscape">A5 Landscape</button>
      </div>
      <div class="footer">Â© 2024 FLOW-FOIL Display Solutions. All rights reserved.</div>
    </div>
  </div>

  <script type="importmap">
    {"imports":{"three":"https://unpkg.com/three@0.152.2/build/three.module.js","three/addons/":"https://unpkg.com/three@0.152.2/examples/jsm/","gsap":"https://cdn.jsdelivr.net/npm/gsap@3.11.5/index.js"}}
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { gsap } from 'gsap';

    const canvas = document.getElementById('canvas');
    const loading = document.querySelector('.loading-overlay');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.domElement.style.touchAction = 'none';
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.48;

    function resize() {
      renderer.setPixelRatio(window.devicePixelRatio);
      const w = window.innerWidth > 768 ? window.innerWidth * 0.45 : window.innerWidth;
      const h = window.innerWidth <= 768 ? window.innerHeight * 0.8 : window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    const camera = new THREE.PerspectiveCamera(65, 1, 0.1, 1000);
    camera.position.set(0, 1.5, -2.73);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, -1, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 1;
    controls.maxDistance = 20;
    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI - 0.1;

    const scene = new THREE.Scene();
    scene.add(new THREE.AmbientLight(0xffffff, 0.726));
    const dl = new THREE.DirectionalLight(0xffffff, 0.7318);
    dl.position.set(2,3,7); dl.castShadow = true; scene.add(dl);
    const fl = new THREE.DirectionalLight(0xffffff, 0.063);
    fl.position.set(-1,4,-3); scene.add(fl);

    let fullModel;
    let glassBaseMesh = null;
    const modelParts = {};
    const sheets = {};
    const sprites = [];
    let active = null;
    let hov = null;
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const draco = new DRACOLoader().setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.5/');
    const gltfLoader = new GLTFLoader().setDRACOLoader(draco);
    const rgbeLoader = new RGBELoader();

    function makeHotspotTex(color) {
      const size = 128;
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d'); const r = size/2;
      ctx.fillStyle = color; ctx.beginPath(); ctx.arc(r,r,r,0,2*Math.PI); ctx.fill();
      ctx.strokeStyle = '#fff'; ctx.lineWidth = size*0.12;
      const L = size*0.6;
      ctx.beginPath(); ctx.moveTo(r-L/2,r); ctx.lineTo(r+L/2,r); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(r,r-L/2); ctx.lineTo(r,r+L/2); ctx.stroke();
      return new THREE.CanvasTexture(c);
    }
    function makeClearHotspotTex(color) {
      const size = 128;
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d'); const r = size/2;
      ctx.fillStyle = color; ctx.beginPath(); ctx.arc(r,r,r,0,2*Math.PI); ctx.fill();
      ctx.strokeStyle = '#fff'; ctx.lineWidth = size*0.12;
      const L = size*0.6;
      ctx.beginPath(); ctx.moveTo(r-L/2,r-L/2); ctx.lineTo(r+L/2,r+L/2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(r+L/2,r-L/2); ctx.lineTo(r-L/2,r+L/2); ctx.stroke();
      return new THREE.CanvasTexture(c);
    }

    const plusTex = makeHotspotTex('#000');
    const plusHoverTex = makeHotspotTex('#06d6a2');
    const clearTex = makeClearHotspotTex('#000');
    const clearHoverTex = makeClearHotspotTex('#ff0000');

    rgbeLoader.load('docklands_02_1k.hdr', hdr => {
      hdr.mapping = THREE.EquirectangularReflectionMapping;
      scene.environment = hdr;
      loadHolder();
    });

    function loadHolder() {
      gltfLoader.load('/adsholder.glb', gltf => {
        fullModel = gltf.scene;
        fullModel.position.set(0,-2,0);
        fullModel.scale.y *= 1.072;
        fullModel.traverse(o => {
          if (o.name) modelParts[o.name] = o;
          if (o.isMesh) {
            o.castShadow = o.receiveShadow = true;
            if (o.material.map) o.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
          }
        });
        modelParts.metalbase && (modelParts.metalbase.visible = true);
        modelParts.glassbase && (modelParts.glassbase.visible = false);
        scene.add(fullModel);

        // initial sheet
        gltfLoader.load('/a4landsr8.glb', g => {
          const sheet = g.scene;
          const bb = new THREE.Box3().setFromObject(sheet);
          sheet.position.y -= bb.min.y;
          const grp = new THREE.Group(); grp.add(sheet);
          grp.position.set(0.004,1.8253-2,0.003);
          grp.quaternion.copy(fullModel.quaternion);
          grp.scale.copy(fullModel.scale);
          scene.add(grp);
          sheets[5] = grp;
          loading.style.display = 'none';
          resize();
        });

        // create hotspots
        const posList = [
          [0.021,1.8253,0.003],[0.021,1.474,0.003],[0.021,1.071,0.003],[0.021,0.688,0.003],[0.021,0.365,0.003],
          [-0.02,1.82753,0.003],[-0.02,1.474,0.003],[-0.02,1.071,0.003],[-0.02,0.688,0.003],[-0.02,0.365,0.003]
        ];
        posList.forEach((p,i) => {
          const zOff = 0.01;
          const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: plusTex, transparent: true }));
          sp.position.set(p[0], p[1] - 2, p[2] + zOff);
          sp.scale.set(0.075, 0.075, 1);
          sp.userData = {
            id: i,
            side: p[0] > 0 ? 'right' : 'left',
            baseZ: p[2],
            textures: { plus: plusTex, hover: plusHoverTex, clear: clearTex }
          };
          scene.add(sp);
          sprites.push(sp);
        });
      });
    }

    // MATERIAL toggle: only one base visible
    document.querySelectorAll('.material-option').forEach(el => el.addEventListener('click', () => {
      document.querySelectorAll('.material-option').forEach(b =>
        b.classList.toggle('active', b === el)
      );
      const mat = el.dataset.material;
      if (mat === 'metal') {
        // remove any loaded glass mesh
        if (glassBaseMesh) {
          scene.remove(glassBaseMesh);
          glassBaseMesh = null;
        }
        modelParts.metalbase && (modelParts.metalbase.visible = true);
        modelParts.glassbase && (modelParts.glassbase.visible = false);
      } else {
        // hide metal
        modelParts.metalbase && (modelParts.metalbase.visible = false);
        // remove old glass if exists
        if (glassBaseMesh) scene.remove(glassBaseMesh);
        // load and add glass base
        gltfLoader.load('/glassbase.glb', g => {
          glassBaseMesh = g.scene;
          glassBaseMesh.position.copy(fullModel.position);
          glassBaseMesh.quaternion.copy(fullModel.quaternion);
          glassBaseMesh.scale.copy(fullModel.scale);
          scene.add(glassBaseMesh);
        });
      }
    }));

    const mapR = { a4vertical:'a4vertlf8', a4landscape:'a4landslf8', a5vertical:'a5vertlf8', a5landscape:'a5landslf8' };
    const mapL = { a4vertical:'a4vertr8', a4landscape:'a4landsr8', a5vertical:'a5vertr8', a5landscape:'a5landsr8' };

    function pick(x,y){
      ray.setFromCamera(new THREE.Vector2(x,y), camera);
      const hit = ray.intersectObjects(sprites)[0];
      return hit ? hit.object : null;
    }

    renderer.domElement.addEventListener('pointerdown', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      const sp = pick(mouse.x, mouse.y);
      if (!sp) return;
      if (sheets[sp.userData.id]) {
        scene.remove(sheets[sp.userData.id]);
        delete sheets[sp.userData.id];
        sp.material.map = sp.userData.textures.plus;
        sp.material.needsUpdate = true;
        active = sp;
      } else if (active === sp) {
        sp.material.map = sp.userData.textures.plus;
        sp.material.needsUpdate = true;
        active = null;
      } else {
        sp.material.map = sp.userData.textures.clear;
        sp.material.needsUpdate = true;
        active = sp;
      }
    }, { passive: false });

    function bindBtns(btns) {
      btns.forEach(b => b.addEventListener('click', () => {
        if (!active) return;
        const fmt = b.dataset.format;
        const side = active.userData.side;
        const file = (side === 'right' ? mapR[fmt] : mapL[fmt]) + '.glb';
        if (sheets[active.userData.id]) {
          scene.remove(sheets[active.userData.id]);
        }
        gltfLoader.load('/' + file, g => {
          const s = g.scene;
          const bb = new THREE.Box3().setFromObject(s);
          s.position.y -= bb.min.y;
          const grp = new THREE.Group();
          grp.add(s);
          const p = active.position.clone();
          p.z = active.userData.baseZ;
          p.x += side === 'left' ? 0.025 : -0.025;
          grp.position.copy(p);
          grp.quaternion.copy(fullModel.quaternion);
          grp.scale.copy(fullModel.scale);
          scene.add(grp);
          sheets[active.userData.id] = grp;
        });
      }));
    }
    bindBtns(document.querySelectorAll('#hotspot-panel button'));
    bindBtns(document.querySelectorAll('#mobile-sheet-buttons button'));

    renderer.domElement.addEventListener('pointermove', e => {
      const rect = canvas.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      const hit = pick(x, y);
      sprites.forEach(sp => {
        if (sp === hit) {
          if (sp.material.map === sp.userData.textures.plus) {
            sp.material.map = sp.userData.textures.hover;
            sp.material.needsUpdate = true;
          } else if (sp.material.map === clearTex) {
            sp.material.map = clearHoverTex;
            sp.material.needsUpdate = true;
          }
        } else {
          if (sp.material.map === sp.userData.textures.hover) {
            sp.material.map = sp.userData.textures.plus;
            sp.material.needsUpdate = true;
          }
          if (sp.material.map === clearHoverTex) {
            sp.material.map = clearTex;
            sp.material.needsUpdate = true;
          }
        }
      });
      if (hit !== hov) {
        if (hov) gsap.to(hov.scale, { x:0.075, y:0.075, duration:0.3, ease:'power2.out' });
        hov = hit;
        if (hov) gsap.to(hov.scale, { x:0.1125, y:0.1125, duration:0.3, ease:'power2.out' });
      }
    });

    resize();
    (function loop(){
      requestAnimationFrame(loop);
      controls.update();
      renderer.render(scene,camera);
    })();
  </script>
</body>
</html>
